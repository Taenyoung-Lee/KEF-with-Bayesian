---
title: "0921_gbi_eb"
author: "Taenyoung Lee"
date: "2025-09-21"
output: html_document
---

```{r}
knitr::opts_chunk$set(
  fig.width = 10,   # A4 가로폭 (inch 단위)
  fig.height = 5,   # A4 세로폭 (원하는 비율로 조정 가능)
  fig.align = "center"
)

```


```{r}

# --------- Linear algebra helpers ---------
safe_chol <- function(M) {
  base <- mean(diag(M))
  eps  <- if (is.finite(base) && base > 0) 1e-10 * base else 1e-10
  for (k in 0:8) {
    out <- try(chol(M + diag(eps, nrow(M))), silent = TRUE)
    if (!inherits(out, "try-error")) return(out)
    eps <- eps * 10
  }
  stop("Cholesky failed. Matrix might be ill-conditioned.")
}
chol_solve <- function(L, B) {
  y <- forwardsolve(t(L), B, upper.tri = FALSE, transpose = FALSE)
  x <- backsolve(L, y, transpose = FALSE)
  x
}
logdet_from_chol <- function(L) 2 * sum(log(diag(L)))

# --------- RBF kernel & derivatives ---------
rbf_kernel <- function(X, sigma) {
  D2 <- as.matrix(dist(X, method = "euclidean"))^2
  exp(- D2 / (2 * sigma^2))
}
grad_k_at <- function(x_t, X, sigma) {
  diff <- matrix(x_t, nrow = nrow(X), ncol = ncol(X), byrow = TRUE) - X
  r2   <- rowSums(diff^2)
  kvec <- exp(- r2 / (2 * sigma^2))
  Gcols <- - (diff / sigma^2) * kvec
  t(Gcols)                         # (d x T)
}
laplacian_k_at <- function(x_t, X, sigma) {
  d <- ncol(X)
  diff <- matrix(x_t, nrow = nrow(X), ncol = ncol(X), byrow = TRUE) - X
  r2 <- rowSums(diff^2)
  kvec <- exp(- r2 / (2 * sigma^2))
  (-d / sigma^2 + r2 / sigma^4) * kvec
}
dK_dsigma <- function(X, sigma, K_precomp = NULL) {
  if (is.null(K_precomp)) K_precomp <- rbf_kernel(X, sigma)
  D2 <- as.matrix(dist(X, method = "euclidean"))^2
  K_precomp * (D2 / sigma^3)
}
dgrad_k_dsigma_at <- function(x_t, X, sigma) {
  diff <- matrix(x_t, nrow = nrow(X), ncol = ncol(X), byrow = TRUE) - X
  r2   <- rowSums(diff^2)
  kvec <- exp(- r2 / (2 * sigma^2))
  factor <- (2 / sigma^3) - (r2 / sigma^5)
  Gsig_cols <- diff * (kvec * factor)
  t(Gsig_cols)                     # (d x T)
}
dlap_k_dsigma_at <- function(x_t, X, sigma) {
  d <- ncol(X)
  diff <- matrix(x_t, nrow = nrow(X), ncol = ncol(X), byrow = TRUE) - X
  r2   <- rowSums(diff^2)
  kvec <- exp(- r2 / (2 * sigma^2))
  kvec * ( (2*d)/sigma^3 - ((d+4)*r2)/sigma^5 + (r2^2)/sigma^7 )
}

# --- score for base density p0 ~ N(0, I) (in standardized space)
score_p0_gaussian <- function(x) { -x }

# --------- Build H, b (with optional p0 score) ---------
build_mats <- function(X, sigma, score_p0 = NULL) {
  Tn <- nrow(X)
  K <- rbf_kernel(X, sigma)
  H <- matrix(0, Tn, Tn)
  b <- numeric(Tn)
  b_p0 <- numeric(Tn)

  for (t in 1:Tn) {
    x_t <- X[t, , drop = FALSE]
    Gt  <- grad_k_at(x_t, X, sigma)           # (d x T)
    H   <- H + crossprod(Gt)                  # T x T
    b   <- b + laplacian_k_at(x_t, X, sigma)  # T
    if (!is.null(score_p0)) {
      s0_at_xt <- score_p0(x_t)               # (1 x d)
      b_p0 <- b_p0 + as.numeric(crossprod(Gt, t(s0_at_xt)))
    }
  }
  H <- H / Tn
  list(K = K, H = H, b = b + b_p0)
}

# --------- (PATCH) sigma-derivatives incl. p0-score term ---------
build_sigma_derivs <- function(X, sigma, K = NULL, score_p0 = NULL) {
  Tn <- nrow(X)
  if (is.null(K)) K <- rbf_kernel(X, sigma)
  dK <- dK_dsigma(X, sigma, K)
  dH <- matrix(0, Tn, Tn)
  db <- numeric(Tn)
  for (t in 1:Tn) {
    x_t <- X[t, , drop = FALSE]
    dGt <- dgrad_k_dsigma_at(x_t, X, sigma)
    dH  <- dH + crossprod(dGt)
    db  <- db + dlap_k_dsigma_at(x_t, X, sigma)
    if (!is.null(score_p0)) {
      s0_at_xt <- score_p0(x_t)
      db <- db + as.numeric(crossprod(dGt, t(s0_at_xt)))
    }
  }
  dH <- dH / Tn
  list(dK = dK, dH = dH, db = db)
}

# --------- 1D normalization helper (for visualization) ---------
dens1d_norm_from_logf <- function(xs, logf){
  m <- max(logf); u <- exp(logf - m)
  dx <- diff(xs); if (length(dx) == 0) stop("xs needs length >= 2")
  if (max(abs(diff(dx))) < 1e-12) {
    Z <- sum(u) * dx[1]
  } else {
    Z <- sum( (u[-1] + u[-length(u)]) / 2 * dx )
  }
  (u / Z)
}

# ======================
# EB (τ = 1) : (λ, σ) 최적화
# ======================
en_elbo_value <- function(K, H, b, lambda, eps) {
  Tn <- length(b)
  Q  <- lambda * K + diag(eps, Tn)
  A  <- H + Q
  LQ <- safe_chol(Q); LA <- safe_chol(A)
  0.5*logdet_from_chol(LQ) - 0.5*logdet_from_chol(LA) +
    0.5 * as.numeric(crossprod(b, chol_solve(LA, b))) / (Tn^2)
}
en_grad_sigma <- function(K, H, b, lambda, eps, dK, dH, db) {
  Tn <- length(b)
  Q <- lambda*K + diag(eps, Tn); A <- H + Q
  LQ <- safe_chol(Q); LA <- safe_chol(A)
  dQ <- lambda*dK; dA <- dH + dQ
  tr_Q <- sum(diag(chol_solve(LQ, dQ)))
  tr_A <- sum(diag(chol_solve(LA, dA)))
  Ainv_b <- chol_solve(LA, b)
  tmp <- chol_solve(LA, dA %*% Ainv_b)
  0.5*tr_Q - 0.5*tr_A + (1/(2*Tn^2))*(2*sum(db*Ainv_b) - as.numeric(crossprod(b, tmp)))
}
en_grad_lambda <- function(K, H, b, lambda, eps) {
  Tn <- length(b)
  Q <- lambda*K + diag(eps, Tn); A <- H + Q
  LQ <- safe_chol(Q); LA <- safe_chol(A)
  tr1 <- sum(diag(chol_solve(LQ, K)))
  tr2 <- sum(diag(chol_solve(LA, K)))
  Ainv_b <- chol_solve(LA, b)
  0.5*tr1 - 0.5*tr2 - (1/(2*Tn^2))*as.numeric(crossprod(Ainv_b, K %*% Ainv_b))
}
solve_alpha_eb <- function(H, K, b, lambda, eps, Tn){
  A  <- H + lambda*K + diag(eps, Tn)
  LA <- safe_chol(A)
  alpha <- -(1/Tn) * chol_solve(LA, b)
  list(alpha = alpha, cholA = LA)
}

ebf_fit <- function(X, sigma_init=NULL, lambda_init=1.0, eps=1e-6,
                    max_iter=200, tol=1e-4, step_sigma=0.3, step_lambda=0.3,
                    standardize=TRUE, sigma_clip_factor=c(0.2,5.0),
                    lambda_bounds=c(1e-8,1e6), score_p0=NULL, verbose=FALSE){
  X <- as.matrix(X); Tn <- nrow(X); d <- ncol(X)
  if (standardize){
    x_center <- colMeans(X); x_scale <- apply(X,2,sd)
    x_scale[!is.finite(x_scale)|x_scale==0] <- 1
    X <- scale(X, center=x_center, scale=x_scale)
  } else { x_center <- rep(0,d); x_scale <- rep(1,d) }
  D <- as.matrix(dist(X)); med_d <- median(D[D>0]); if(!is.finite(med_d)||med_d<=0) med_d <- 1
  smin <- sigma_clip_factor[1]*med_d; smax <- sigma_clip_factor[2]*med_d
  sigma <- if(is.null(sigma_init)) med_d else sigma_init
  sigma <- min(max(sigma,smin),smax); lnsigma <- log(sigma)
  lambda <- min(max(lambda_init, lambda_bounds[1]), lambda_bounds[2]); lnlambda <- log(lambda)

  mats <- build_mats(X, sigma, score_p0)
  Lcur <- en_elbo_value(mats$K, mats$H, mats$b, lambda, eps)

  for (it in 1:max_iter){
    improved <- FALSE
    gl <- en_grad_lambda(mats$K, mats$H, mats$b, lambda, eps)
    g  <- lambda*gl; if(!is.finite(g)) g <- 0; step <- step_lambda
    for (ls in 1:20){
      lambda_try <- exp(lnlambda + step*g)
      lambda_try <- min(max(lambda_try, lambda_bounds[1]), lambda_bounds[2])
      Ltry <- en_elbo_value(mats$K, mats$H, mats$b, lambda_try, eps)
      if (is.finite(Ltry) && Ltry >= Lcur - 1e-12){
        lambda <- lambda_try; lnlambda <- log(lambda); Lcur <- Ltry; improved <- TRUE; break
      } else step <- step/2
    }
    ders <- build_sigma_derivs(X, sigma, K=mats$K, score_p0=score_p0)
    gs <- en_grad_sigma(mats$K, mats$H, mats$b, lambda, eps, ders$dK, ders$dH, ders$db)
    g  <- sigma*gs; if(!is.finite(g)) g <- 0; step <- step_sigma
    for (ls in 1:20){
      sigma_try <- exp(lnsigma + step*g)
      sigma_try <- min(max(sigma_try, smin), smax)
      mats_try <- build_mats(X, sigma_try, score_p0)
      Ltry <- en_elbo_value(mats_try$K, mats_try$H, mats_try$b, lambda, eps)
      if (is.finite(Ltry) && Ltry >= Lcur - 1e-12){
        sigma <- sigma_try; lnsigma <- log(sigma); mats <- mats_try; Lcur <- Ltry; improved <- TRUE; break
      } else step <- step/2
    }
    if (!improved) break
    if (max(abs(g*step), abs(gl*lambda*step_lambda)) < tol) break
  }
  sol <- solve_alpha_eb(mats$H, mats$K, mats$b, lambda, eps, Tn)
  list(X=X, sigma=sigma, lambda=lambda, eps=eps, elbo=Lcur, alpha=sol$alpha,
       H=mats$H, K=mats$K, b=mats$b, x_center=x_center, x_scale=x_scale,
       standardize=standardize, score_p0=score_p0)
}

predict_f_eb <- function(fit, Xnew, jacobian_correction = FALSE){
  Xnew <- as.matrix(Xnew)
  if (isTRUE(fit$standardize)){
    Xstd <- sweep(Xnew, 2, fit$x_center, "-")
    Xstd <- sweep(Xstd, 2, fit$x_scale,  "/")
  } else Xstd <- Xnew
  log_p0_val <- if (!is.null(fit$score_p0)) -0.5 * rowSums(Xstd^2) else 0
  Tn <- nrow(fit$X); out <- matrix(0, nrow(Xstd), Tn)
  for (i in 1:nrow(Xstd)){
    diff <- sweep(fit$X, 2, Xstd[i,], FUN="-"); r2 <- rowSums(diff^2)
    out[i,] <- exp(- r2 / (2 * fit$sigma^2))
  }
  f <- as.numeric(out %*% fit$alpha) + log_p0_val
  if (jacobian_correction && isTRUE(fit$standardize)) f <- f - sum(log(fit$x_scale))
  f
}
predict_den_eb <- function(fit, Xnew, jacobian_correction = FALSE) exp(predict_f_eb(fit, Xnew, jacobian_correction))

# ======================
# GBI (τ 최적화): λ 고정
# ======================
GBI_elbo <- function(K, H, b, lambda_fixed, tau, eps){
  Tn <- length(b)
  Q  <- lambda_fixed*K + diag(eps, Tn)
  R  <- tau*H + Q
  LQ <- safe_chol(Q); LR <- safe_chol(R)
  0.5*logdet_from_chol(LQ) - 0.5*logdet_from_chol(LR) +
    0.5 * (tau^2/Tn^2) * as.numeric(crossprod(b, chol_solve(LR, b)))
}
gbi_grad_tau <- function(K, H, b, lambda_fixed, tau, eps){
  Tn <- length(b)
  Q  <- lambda_fixed*K + diag(eps,Tn); R <- tau*H + Q
  LR <- safe_chol(R)
  tr_Rinv_H <- sum(diag(chol_solve(LR, H)))
  Rinv_b <- chol_solve(LR, b)
  bRinvb <- as.numeric(crossprod(b, Rinv_b))
  quad_H  <- as.numeric(crossprod(Rinv_b, H %*% Rinv_b))
  -0.5*tr_Rinv_H + (tau/Tn^2)*bRinvb - 0.5*(tau^2/Tn^2)*quad_H
}
gbi_grad_sigma <- function(K, H, b, lambda_fixed, tau, eps, dK, dH, db){
  Tn <- length(b)
  Q  <- lambda_fixed*K + diag(eps,Tn); R <- tau*H + Q
  LQ <- safe_chol(Q); LR <- safe_chol(R)
  dQ <- lambda_fixed*dK; dR <- tau*dH + dQ
  tr_Q <- sum(diag(chol_solve(LQ, dQ)))
  tr_R <- sum(diag(chol_solve(LR, dR)))
  Rinv_b <- chol_solve(LR, b)
  tmp    <- chol_solve(LR, dR %*% Rinv_b)
  0.5*tr_Q - 0.5*tr_R + (tau^2/(2*Tn^2))*(2*sum(db*Rinv_b) - as.numeric(crossprod(b, tmp)))
}
solve_post_gbi <- function(H, K, b, lambda_fixed, tau, eps, Tn, return_cov = FALSE, diag_only = TRUE){
  R  <- tau*H + lambda_fixed*K + diag(eps, Tn)
  LR <- safe_chol(R)
  m  <- -(tau/Tn) * chol_solve(LR, b)

  if (!return_cov) {
    return(list(m = m, cholR = LR))
  }
  if (diag_only) {
    S_diag <- diag(chol2inv(LR))
    return(list(m = m, cholR = LR, S_diag = S_diag))
  } else {
    S <- chol2inv(LR)
    return(list(m = m, cholR = LR, S = S))
  }
}

fit_gbi <- function(X, sigma_init=NULL, lambda_fixed=1.0, tau_init=1.0, eps=1e-6,
                    max_iter=200, tol=1e-4, step_sigma=0.2, step_tau=0.2,
                    standardize=TRUE, sigma_clip_factor=c(0.2,5.0),
                    tau_bounds=c(1e-3,1e3), score_p0=NULL, verbose=FALSE){
  X <- as.matrix(X); Tn <- nrow(X); d <- ncol(X)
  if (standardize){
    x_center <- colMeans(X); x_scale <- apply(X,2,sd)
    x_scale[!is.finite(x_scale)|x_scale==0] <- 1
    X <- scale(X, center=x_center, scale=x_scale)
  } else { x_center <- rep(0,d); x_scale <- rep(1,d) }
  D <- as.matrix(dist(X)); med_d <- median(D[D>0]); if(!is.finite(med_d)||med_d<=0) med_d <- 1
  smin <- sigma_clip_factor[1]*med_d; smax <- sigma_clip_factor[2]*med_d
  sigma <- if(is.null(sigma_init)) med_d else sigma_init
  sigma <- min(max(sigma,smin),smax); lnsigma <- log(sigma)
  tau   <- min(max(tau_init, tau_bounds[1]), tau_bounds[2]); lntau <- log(tau)

  mats <- build_mats(X, sigma, score_p0)
  Lcur <- GBI_elbo(mats$K, mats$H, mats$b, lambda_fixed, tau, eps)

  for (it in 1:max_iter){
    improved <- FALSE
    gt <- gbi_grad_tau(mats$K, mats$H, mats$b, lambda_fixed, tau, eps)
    g  <- tau*gt; if(!is.finite(g)) g <- 0; step <- step_tau
    for (ls in 1:20){
      tau_try <- exp(lntau + step*g)
      tau_try <- min(max(tau_try, tau_bounds[1]), tau_bounds[2])
      Ltry <- GBI_elbo(mats$K, mats$H, mats$b, lambda_fixed, tau_try, eps)
      if (is.finite(Ltry) && Ltry >= Lcur - 1e-12){
        tau <- tau_try; lntau <- log(tau); Lcur <- Ltry; improved <- TRUE; break
      } else step <- step/2
    }
    ders <- build_sigma_derivs(X, sigma, K=mats$K, score_p0=score_p0)
    gs <- gbi_grad_sigma(mats$K, mats$H, mats$b, lambda_fixed, tau, eps, ders$dK, ders$dH, ders$db)
    g  <- sigma*gs; if(!is.finite(g)) g <- 0; step <- step_sigma
    for (ls in 1:20){
      sigma_try <- exp(lnsigma + step*g)
      sigma_try <- min(max(sigma_try, smin), smax)
      mats_try <- build_mats(X, sigma_try, score_p0)
      Ltry <- GBI_elbo(mats_try$K, mats_try$H, mats_try$b, lambda_fixed, tau, eps)
      if (is.finite(Ltry) && Ltry >= Lcur - 1e-12){
        sigma <- sigma_try; lnsigma <- log(sigma); mats <- mats_try; Lcur <- Ltry; improved <- TRUE; break
      } else step <- step/2
    }
    if (!improved) break
    if (max(abs(gt*tau*step_tau), abs(gs*sigma*step_sigma)) < tol) break
  }
  post <- solve_post_gbi(mats$H, mats$K, mats$b, lambda_fixed, tau, eps, Tn,
                         return_cov = TRUE, diag_only = TRUE)
  out <- list(
    X=X, sigma=sigma, lambda=lambda_fixed, tau=tau, eps=eps, elbo=Lcur, m=post$m,
    H=mats$H, K=mats$K, b=mats$b, x_center=x_center, x_scale=x_scale,
    standardize=standardize, score_p0=score_p0,
    cholR = post$cholR, S_diag = post$S_diag
  )
  return(out)
}

predict_f_gbi <- function(fit, Xnew, jacobian_correction = FALSE){
  Xnew <- as.matrix(Xnew)
  if (isTRUE(fit$standardize)){
    Xstd <- sweep(Xnew, 2, fit$x_center, "-")
    Xstd <- sweep(Xstd, 2, fit$x_scale,  "/")
  } else Xstd <- Xnew
  log_p0_val <- if (!is.null(fit$score_p0)) -0.5 * rowSums(Xstd^2) else 0
  Tn <- nrow(fit$X); out <- matrix(0, nrow(Xstd), Tn)
  for (i in 1:nrow(Xstd)){
    diff <- sweep(fit$X, 2, Xstd[i,], FUN="-"); r2 <- rowSums(diff^2)
    out[i,] <- exp(- r2 / (2 * fit$sigma^2))
  }
  f <- as.numeric(out %*% fit$m) + log_p0_val
  if (jacobian_correction && isTRUE(fit$standardize)) f <- f - sum(log(fit$x_scale))
  f
}
predict_den_gbi <- function(fit, Xnew, jacobian_correction = FALSE) exp(predict_f_gbi(fit, Xnew, jacobian_correction))

# ======================
# Helpers for variance & bands
# ======================
eb_posterior_diag <- function(fit){
  Tn <- nrow(fit$K)
  A  <- fit$H + fit$lambda*fit$K + diag(fit$eps, Tn)
  LA <- safe_chol(A)
  S_diag <- diag(chol2inv(LA))
  list(LA=LA, S_diag=S_diag)
}

predict_var_f_from_chol <- function(cholMat, Xtrain, sigma, Xnew){
  Xnew <- as.matrix(Xnew)
  Tn <- nrow(Xtrain)
  Kx <- matrix(0, nrow(Xnew), Tn)
  for (i in 1:nrow(Xnew)){
    diff <- sweep(Xtrain, 2, Xnew[i,], FUN="-")
    r2   <- rowSums(diff^2)
    Kx[i,] <- exp(- r2 / (2 * sigma^2))
  }
  vars <- numeric(nrow(Kx))
  for (i in 1:nrow(Kx)){
    v <- chol_solve(cholMat, Kx[i,])     # v = R^{-1} k_x  (또는 A^{-1} k_x)
    vars[i] <- sum(Kx[i,] * v)           # k_x^T v
  }
  vars
}

# 로그밀도 밴드를 density 스케일로 정규화해 반환
make_density_band <- function(xs, f, varf, z = 2){
  sdv <- sqrt(pmax(varf, 0))
  f_lo <- f - z*sdv
  f_hi <- f + z*sdv
  d_mid <- dens1d_norm_from_logf(xs, f)
  d_lo  <- dens1d_norm_from_logf(xs, f_lo)
  d_hi  <- dens1d_norm_from_logf(xs, f_hi)
  list(d_mid=d_mid, d_lo=d_lo, d_hi=d_hi, sd=sdv)
}

label_eb <- function(fit, S_diag=NULL){
  if (is.null(S_diag)) S_diag <- rep(NA_real_, nrow(fit$K))
  sprintf("EB  σ=%.3g, λ=%.3g, ε=%.1e, ELBO=%.3f\nVar(α) mean=%.2e, min=%.2e, max=%.2e",
          fit$sigma, fit$lambda, fit$eps, fit$elbo,
          mean(S_diag), min(S_diag), max(S_diag))
}
label_gbi <- function(fit){
  S_diag <- fit$S_diag
  sprintf("GBI τ=%.3g, σ=%.3g, λ=%.3g, ε=%.1e, ELBO=%.3f\nVar(α) mean=%.2e, min=%.2e, max=%.2e",
          fit$tau, fit$sigma, fit$lambda, fit$eps, fit$elbo,
          mean(S_diag), min(S_diag), max(S_diag))
}

# 밀도 + 밴드 그리기
plot_density_with_band <- function(x_hist, xs, band, main, line_col="blue",
                                   true_xs=NULL, true_den=NULL){
  # 좌측: 히스토그램과 밴드/곡선
  ylim_max <- max( c(band$d_hi, if(!is.null(true_den)) true_den else 0) )
  hist(x_hist, breaks=30, freq=FALSE, main=main, xlab="x",
       col="grey90", border="white", ylim=c(0, ylim_max))

  # 밴드(반투명)
  polygon(c(xs, rev(xs)), c(band$d_lo, rev(band$d_hi)),
          col=rgb(0, 0, 1, alpha=0.15), border=NA)

  # 추정 곡선
  lines(xs, band$d_mid, lwd=2, col=line_col)

  # True (있으면)
  if (!is.null(true_den)) {
    lines(true_xs, true_den, lwd=2, lty=2, col="gray40")
    legend("topright", legend=c("Estimate", "Band (±2sd)", "True"),
           col=c(line_col, rgb(0,0,1,0.3), "gray40"),
           lty=c(1,1,2), lwd=c(2,10,2), bty="n",
           pt.cex=c(NA, NA, NA))
  } else {
    legend("topright", legend=c("Estimate", "Band (±2sd)"),
           col=c(line_col, rgb(0,0,1,0.3)),
           lty=c(1,1), lwd=c(2,10), bty="n")
  }
}

```


## 1d bimodal


```{r}

set.seed(101)
X1_mix <- matrix(c(rnorm(200, -2, 0.7), rnorm(200, 2, 0.7)), ncol = 1)

# EB
fit_eb <- ebf_fit(X1_mix, eps=1e-6, score_p0 = score_p0_gaussian)
xs <- seq(min(X1_mix)-2, max(X1_mix)+2, length.out=400)
f_eb   <- predict_f_eb(fit_eb, xs)
eb_post <- eb_posterior_diag(fit_eb)
varf_eb <- predict_var_f_from_chol(eb_post$LA, fit_eb$X, fit_eb$sigma, xs)
band_eb <- make_density_band(xs, f_eb, varf_eb, z=2)
ttl_eb  <- label_eb(fit_eb, eb_post$S_diag)

# GBI
fit_gb <- fit_gbi(X1_mix, eps=1e-6, score_p0 = score_p0_gaussian)
f_gb   <- predict_f_gbi(fit_gb, xs)
varf_gb <- predict_var_f_from_chol(fit_gb$cholR, fit_gb$X, fit_gb$sigma, xs)
band_gb <- make_density_band(xs, f_gb, varf_gb, z=2)
ttl_gb  <- label_gbi(fit_gb)

# True
d_true <- 0.5 * dnorm(xs, -2, 0.7) + 0.5 * dnorm(xs, 2, 0.7)

plot_density_with_band(X1_mix, xs, band_eb, main=ttl_eb, line_col="blue",
                       true_xs=xs, true_den=d_true)
plot_density_with_band(X1_mix, xs, band_gb, main=ttl_gb, line_col="red",
                       true_xs=xs, true_den=d_true)



```



## 1d gamam


```{r}


set.seed(102)
X1_gamma <- matrix(rgamma(300, shape = 2, rate = 1.5), ncol = 1)

# EB
fit_eb <- ebf_fit(X1_gamma, eps=1e-6, score_p0 = score_p0_gaussian)
xs <- seq(0, max(X1_gamma)+2, length.out=400)
f_eb   <- predict_f_eb(fit_eb, xs)
eb_post <- eb_posterior_diag(fit_eb)
varf_eb <- predict_var_f_from_chol(eb_post$LA, fit_eb$X, fit_eb$sigma, xs)
band_eb <- make_density_band(xs, f_eb, varf_eb, z=2)
ttl_eb  <- label_eb(fit_eb, eb_post$S_diag)

# GBI
fit_gb <- fit_gbi(X1_gamma, eps=1e-6, score_p0 = score_p0_gaussian)
f_gb   <- predict_f_gbi(fit_gb, xs)
varf_gb <- predict_var_f_from_chol(fit_gb$cholR, fit_gb$X, fit_gb$sigma, xs)
band_gb <- make_density_band(xs, f_gb, varf_gb, z=2)
ttl_gb  <- label_gbi(fit_gb)

# True
d_true <- dgamma(xs, shape = 2, rate = 1.5)


plot_density_with_band(X1_gamma, xs, band_eb, main=ttl_eb, line_col="blue",
                       true_xs=xs, true_den=d_true)
plot_density_with_band(X1_gamma, xs, band_gb, main=ttl_gb, line_col="red",
                       true_xs=xs, true_den=d_true)


```


