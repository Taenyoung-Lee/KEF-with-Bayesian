---
title: "KEF + Score Matching: EB (τ=1) vs GBI (τ optimized): 1d Datasets"
author: "Taenyoung Lee"
date: "`r format(Sys.Date())`"
output:
  html_document:
    toc: true
    toc_depth: 3
    number_sections: true
    toc_float: true
    df_print: paged
    code_folding: hide
    theme: readable
fontsize: 11pt
geometry: margin=1in
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE, message = FALSE, warning = FALSE,
  fig.width = 7, fig.height = 4.6
)
set.seed(1)
```



```{r 공통 유틸리티 & 수식 구성 요소 (공유)}
# --------- Linear algebra helpers ---------
safe_chol <- function(M) {
  base <- mean(diag(M))
  eps  <- if (is.finite(base) && base > 0) 1e-10 * base else 1e-10
  for (k in 0:8) {
    out <- try(chol(M + diag(eps, nrow(M))), silent = TRUE)
    if (!inherits(out, "try-error")) return(out)
    eps <- eps * 10
  }
  stop("Cholesky failed. Matrix might be ill-conditioned.")
}
chol_solve <- function(L, B) {
  y <- forwardsolve(t(L), B, upper.tri = FALSE, transpose = FALSE)
  x <- backsolve(L, y, transpose = FALSE)
  x
}
logdet_from_chol <- function(L) 2 * sum(log(diag(L)))

# --------- RBF kernel & derivatives ---------
rbf_kernel <- function(X, sigma) {
  D2 <- as.matrix(dist(X, method = "euclidean"))^2
  exp(- D2 / (2 * sigma^2))
}
grad_k_at <- function(x_t, X, sigma) {
  diff <- matrix(x_t, nrow = nrow(X), ncol = ncol(X), byrow = TRUE) - X
  r2   <- rowSums(diff^2)
  kvec <- exp(- r2 / (2 * sigma^2))
  Gcols <- - (diff / sigma^2) * kvec
  t(Gcols)
}
laplacian_k_at <- function(x_t, X, sigma) {
  d <- ncol(X)
  diff <- matrix(x_t, nrow = nrow(X), ncol = ncol(X), byrow = TRUE) - X
  r2 <- rowSums(diff^2)
  kvec <- exp(- r2 / (2 * sigma^2))
  (-d / sigma^2 + r2 / sigma^4) * kvec
}
dK_dsigma <- function(X, sigma, K_precomp = NULL) {
  if (is.null(K_precomp)) K_precomp <- rbf_kernel(X, sigma)
  D2 <- as.matrix(dist(X, method = "euclidean"))^2
  K_precomp * (D2 / sigma^3)
}
dgrad_k_dsigma_at <- function(x_t, X, sigma) {
  diff <- matrix(x_t, nrow = nrow(X), ncol = ncol(X), byrow = TRUE) - X
  r2   <- rowSums(diff^2)
  kvec <- exp(- r2 / (2 * sigma^2))
  factor <- (2 / sigma^3) - (r2 / sigma^5)
  Gsig_cols <- diff * (kvec * factor)
  t(Gsig_cols)
}
dlap_k_dsigma_at <- function(x_t, X, sigma) {
  d <- ncol(X)
  diff <- matrix(x_t, nrow = nrow(X), ncol = ncol(X), byrow = TRUE) - X
  r2   <- rowSums(diff^2)
  kvec <- exp(- r2 / (2 * sigma^2))
  kvec * ( (2*d)/sigma^3 - ((d+4)*r2)/sigma^5 + (r2^2)/sigma^7 )
}

# --- NEW: Score function for a standard Gaussian basis density p0 ---
# For standardized data, p0 ~ N(0, I) is a good choice. Its score is -x.
score_p0_gaussian <- function(x) {
  -x
}


# --- MODIFIED: Build H, b, incorporating the score of p0 ---
build_mats <- function(X, sigma, score_p0 = NULL) {
  Tn <- nrow(X)
  K <- rbf_kernel(X, sigma)
  H <- matrix(0, Tn, Tn)
  b <- numeric(Tn)
  b_p0 <- numeric(Tn) # Component from the basis density p0

  for (t in 1:Tn) {
    x_t <- X[t, , drop = FALSE]
    Gt <- grad_k_at(x_t, X, sigma)      # d x T matrix
    H  <- H + crossprod(Gt)             # T x T
    b  <- b + laplacian_k_at(x_t, X, sigma)
    
    # If a score function for p0 is provided, calculate its contribution
    if (!is.null(score_p0)) {
      s0_at_xt <- score_p0(x_t) # This is a 1 x d vector
      # Add the term E[∇f(x)ᵀs₀(x)], which is linear in α
      b_p0 <- b_p0 + as.numeric(crossprod(Gt, t(s0_at_xt)))
    }
  }
  H <- H / Tn
  
  list(K = K, H = H, b = b + b_p0) # Add the new component to b
}

build_sigma_derivs <- function(X, sigma, K = NULL) {
  Tn <- nrow(X)
  if (is.null(K)) K <- rbf_kernel(X, sigma)
  dK <- dK_dsigma(X, sigma, K)
  dH <- matrix(0, Tn, Tn)
  db <- numeric(Tn) # Note: sigma-deriv of b_p0 is not implemented for simplicity
  for (t in 1:Tn) {
    dGt <- dgrad_k_dsigma_at(X[t, , drop = FALSE], X, sigma)
    dH  <- dH + crossprod(dGt)
    db  <- db + dlap_k_dsigma_at(X[t, , drop = FALSE], X, sigma)
  }
  dH <- dH / Tn
  list(dK = dK, dH = dH, db = db)
}

# --------- 1D normalization helper ---------
dens1d_norm_from_logf <- function(xs, logf){
  m <- max(logf)
  u <- exp(logf - m)
  dx <- diff(xs)
  if (length(dx) == 0) stop("xs needs length >= 2")
  if (max(abs(diff(dx))) < 1e-12) {
    Z <- sum(u) * dx[1]
  } else {
    Z <- sum( (u[-1] + u[-length(u)]) / 2 * dx )
  }
  (u / Z)
}
dens1d_eb <- function(fit, xs){ dens1d_norm_from_logf(xs, predict_f_eb(fit, xs)) }
dens1d_gbi <- function(fit, xs){ dens1d_norm_from_logf(xs, predict_f_gbi(fit, xs)) }
```



```{r EB}
en_elbo_value <- function(K, H, b, lambda, eps) {
  Tn <- length(b)
  Q <- lambda * K + diag(eps, Tn)
  A <- H + Q
  LQ <- safe_chol(Q); LA <- safe_chol(A)
  0.5*logdet_from_chol(LQ) - 0.5*logdet_from_chol(LA) +
    0.5 * as.numeric(crossprod(b, chol_solve(LA, b))) / (Tn^2)
}
en_grad_sigma <- function(K, H, b, lambda, eps, dK, dH, db) {
  Tn <- length(b)
  Q <- lambda*K + diag(eps, Tn); A <- H + Q
  LQ <- safe_chol(Q); LA <- safe_chol(A)
  dQ <- lambda*dK; dA <- dH + dQ
  tr_Q <- sum(diag(chol_solve(LQ, dQ)))
  tr_A <- sum(diag(chol_solve(LA, dA)))
  Ainv_b <- chol_solve(LA, b)
  tmp <- chol_solve(LA, dA %*% Ainv_b)
  0.5*tr_Q - 0.5*tr_A + (1/(2*Tn^2))*(2*sum(db*Ainv_b) - as.numeric(crossprod(b, tmp)))
}
en_grad_lambda <- function(K, H, b, lambda, eps) {
  Tn <- length(b)
  Q <- lambda*K + diag(eps, Tn); A <- H + Q
  LQ <- safe_chol(Q); LA <- safe_chol(A)
  tr1 <- sum(diag(chol_solve(LQ, K)))
  tr2 <- sum(diag(chol_solve(LA, K)))
  Ainv_b <- chol_solve(LA, b)
  0.5*tr1 - 0.5*tr2 - (1/(2*Tn^2))*as.numeric(crossprod(Ainv_b, K %*% Ainv_b))
}
solve_alpha_eb <- function(H, K, b, lambda, eps, Tn){
  A <- H + lambda*K + diag(eps, Tn)
  LA <- safe_chol(A)
  alpha <- -(1/Tn) * chol_solve(LA, b)
  list(alpha = alpha, cholA = LA)
}

# --- MODIFIED: ebf_fit to accept score_p0 ---
ebf_fit <- function(X, sigma_init=NULL, lambda_init=1.0, eps=1e-6,
                    max_iter=200, tol=1e-4, step_sigma=0.3, step_lambda=0.3,
                    standardize=TRUE, sigma_clip_factor=c(0.2,5.0),
                    lambda_bounds=c(1e-8,1e6), score_p0=NULL, verbose=FALSE){
  X <- as.matrix(X); Tn <- nrow(X); d <- ncol(X)
  if (standardize){ 
    x_center <- colMeans(X); x_scale <- apply(X,2,sd);
    x_scale[!is.finite(x_scale)|x_scale==0] <- 1
    X <- scale(X, center=x_center, scale=x_scale)
  } else { 
    x_center <- rep(0,d); x_scale <- rep(1,d) 
  }
  D <- as.matrix(dist(X)); med_d <- median(D[D>0]); if(!is.finite(med_d)||med_d<=0) med_d <- 1
  smin <- sigma_clip_factor[1]*med_d; smax <- sigma_clip_factor[2]*med_d
  sigma <- if(is.null(sigma_init)) med_d else sigma_init
  sigma <- min(max(sigma,smin),smax); lnsigma <- log(sigma)
  lambda <- min(max(lambda_init, lambda_bounds[1]), lambda_bounds[2]); lnlambda <- log(lambda)
  
  mats <- build_mats(X, sigma, score_p0)
  
  Lcur <- en_elbo_value(mats$K, mats$H, mats$b, lambda, eps)
  for (it in 1:max_iter){
    improved <- FALSE
    gl <- en_grad_lambda(mats$K, mats$H, mats$b, lambda, eps)
    g <- lambda*gl; if(!is.finite(g)) g <- 0; step <- step_lambda
    for (ls in 1:20){
      lambda_try <- exp(lnlambda + step*g)
      lambda_try <- min(max(lambda_try, lambda_bounds[1]), lambda_bounds[2])
      Ltry <- en_elbo_value(mats$K, mats$H, mats$b, lambda_try, eps)
      if (is.finite(Ltry) && Ltry >= Lcur - 1e-12){ lambda <- lambda_try; lnlambda<-log(lambda); Lcur<-Ltry; improved<-TRUE; break } else step <- step/2
    }
    ders <- build_sigma_derivs(X, sigma, K=mats$K)
    gs <- en_grad_sigma(mats$K, mats$H, mats$b, lambda, eps, ders$dK, ders$dH, ders$db)
    g <- sigma*gs; if(!is.finite(g)) g <- 0; step <- step_sigma
    for (ls in 1:20){
      sigma_try <- exp(lnsigma + step*g)
      sigma_try <- min(max(sigma_try, smin), smax)
      mats_try <- build_mats(X, sigma_try, score_p0)
      Ltry <- en_elbo_value(mats_try$K, mats_try$H, mats_try$b, lambda, eps)
      if (is.finite(Ltry) && Ltry >= Lcur - 1e-12){ sigma<-sigma_try; lnsigma<-log(sigma); mats<-mats_try; Lcur<-Ltry; improved<-TRUE; break } else step <- step/2
    }
    if (!improved || step_sigma*abs(g) < tol) break
  }
  sol <- solve_alpha_eb(mats$H, mats$K, mats$b, lambda, eps, Tn)
  list(X=X, sigma=sigma, lambda=lambda, eps=eps, elbo=Lcur, alpha=sol$alpha,
       H=mats$H, K=mats$K, b=mats$b, x_center=x_center, x_scale=x_scale, 
       standardize=standardize, score_p0=score_p0)
}
# predict (EB)
predict_f_eb <- function(fit, Xnew){
  Xnew <- as.matrix(Xnew)
  log_p0_val <- 0
  if (isTRUE(fit$standardize)){
    Xnew_std <- sweep(Xnew, 2, fit$x_center, "-")
    Xnew_std <- sweep(Xnew_std, 2, fit$x_scale,  "/")
  } else {
    Xnew_std <- Xnew
  }
  if (!is.null(fit$score_p0)) {
      # Assuming p0 is N(0,I), log p0(x) = -0.5 * sum(x^2) + C
      log_p0_val <- -0.5 * rowSums(Xnew_std^2)
  }
  Tn <- nrow(fit$X); out <- matrix(0, nrow(Xnew_std), Tn)
  for (i in 1:nrow(Xnew_std)){
    diff <- sweep(fit$X, 2, Xnew_std[i,], FUN="-"); r2 <- rowSums(diff^2)
    out[i,] <- exp(- r2 / (2 * fit$sigma^2))
  }
  as.numeric(out %*% fit$alpha) + log_p0_val
}
predict_den_eb <- function(fit, Xnew) exp(predict_f_eb(fit, Xnew))
```



```{r GBI}
GBI_elbo <- function(K, H, b, lambda, tau, eps){
  Tn <- length(b)
  Q <- lambda*K + diag(eps, Tn)
  R <- tau*H + Q
  LQ <- safe_chol(Q); LR <- safe_chol(R)
  0.5*logdet_from_chol(LQ) - 0.5*logdet_from_chol(LR) +
    0.5 * (tau^2/Tn^2) * as.numeric(crossprod(b, chol_solve(LR, b)))
}
gbi_grad_lambda <- function(K, H, b, lambda, tau, eps){
  Tn <- length(b)
  Q <- lambda*K + diag(eps,Tn); R <- tau*H + Q
  LQ <- safe_chol(Q); LR <- safe_chol(R)
  tr1 <- sum(diag(chol_solve(LQ, K)))
  tr2 <- sum(diag(chol_solve(LR, K)))
  Rinv_b <- chol_solve(LR, b)
  0.5*tr1 - 0.5*tr2 - 0.5*(tau^2/Tn^2)*as.numeric(crossprod(Rinv_b, K %*% Rinv_b))
}
gbi_grad_tau <- function(K, H, b, lambda, tau, eps){
  Tn <- length(b)
  Q <- lambda*K + diag(eps,Tn); R <- tau*H + Q
  LR <- safe_chol(R)
  tr_Rinv_H <- sum(diag(chol_solve(LR, H)))
  Rinv_b <- chol_solve(LR, b)
  bRinvb <- as.numeric(crossprod(b, Rinv_b))
  quad_H  <- as.numeric(crossprod(Rinv_b, H %*% Rinv_b))
  -0.5*tr_Rinv_H + (tau/Tn^2)*bRinvb - 0.5*(tau^2/Tn^2)*quad_H
}
gbi_grad_sigma <- function(K, H, b, lambda, tau, eps, dK, dH, db){
  Tn <- length(b)
  Q <- lambda*K + diag(eps,Tn); R <- tau*H + Q
  LQ <- safe_chol(Q); LR <- safe_chol(R)
  dQ <- lambda*dK; dR <- tau*dH + dQ
  tr_Q <- sum(diag(chol_solve(LQ, dQ)))
  tr_R <- sum(diag(chol_solve(LR, dR)))
  Rinv_b <- chol_solve(LR, b)
  tmp    <- chol_solve(LR, dR %*% Rinv_b)
  0.5*tr_Q - 0.5*tr_R + (tau^2/(2*Tn^2))*(2*sum(db*Rinv_b) - as.numeric(crossprod(b, tmp)))
}
solve_post_gbi <- function(H, K, b, lambda, tau, eps, Tn){
  R <- tau*H + lambda*K + diag(eps, Tn)
  LR <- safe_chol(R)
  m <- -(tau/Tn) * chol_solve(LR, b)
  list(m=m, cholR=LR)
}

# --- MODIFIED: fit_gbi to accept score_p0 ---
fit_gbi <- function(X, sigma_init=NULL, lambda_init=1.0, tau_init=1.0, eps=1e-6,
                    max_iter=200, tol=1e-4, step_sigma=0.2, step_lambda=0.2, step_tau=0.2,
                    standardize=TRUE, sigma_clip_factor=c(0.2,5.0),
                    lambda_bounds=c(1e-8,1e6), tau_bounds=c(1e-3,1e3), 
                    score_p0=NULL, verbose=FALSE){
  X <- as.matrix(X); Tn <- nrow(X); d <- ncol(X)
  if (standardize){ 
    x_center <- colMeans(X); x_scale <- apply(X,2,sd);
    x_scale[!is.finite(x_scale)|x_scale==0] <- 1; X <- scale(X, center=x_center, scale=x_scale)
  } else { 
    x_center <- rep(0,d); x_scale <- rep(1,d) 
  }
  D <- as.matrix(dist(X)); med_d <- median(D[D>0]); if(!is.finite(med_d)||med_d<=0) med_d <- 1
  smin <- sigma_clip_factor[1]*med_d; smax <- sigma_clip_factor[2]*med_d
  sigma <- if(is.null(sigma_init)) med_d else sigma_init
  sigma <- min(max(sigma,smin),smax); lnsigma <- log(sigma)
  lambda <- min(max(lambda_init, lambda_bounds[1]), lambda_bounds[2]); lnlambda <- log(lambda)
  tau <- min(max(tau_init, tau_bounds[1]), tau_bounds[2]); lntau <- log(tau)

  mats <- build_mats(X, sigma, score_p0)
  
  Lcur <- GBI_elbo(mats$K, mats$H, mats$b, lambda, tau, eps)
  for (it in 1:max_iter){
    improved <- FALSE
    gl <- gbi_grad_lambda(mats$K, mats$H, mats$b, lambda, tau, eps)
    g <- lambda*gl; if(!is.finite(g)) g <- 0; step <- step_lambda
    for (ls in 1:20){
      lambda_try <- exp(lnlambda + step*g)
      lambda_try <- min(max(lambda_try, lambda_bounds[1]), lambda_bounds[2])
      Ltry <- GBI_elbo(mats$K, mats$H, mats$b, lambda_try, tau, eps)
      if (is.finite(Ltry) && Ltry >= Lcur - 1e-12){ lambda<-lambda_try; lnlambda<-log(lambda); Lcur<-Ltry; improved<-TRUE; break } else step <- step/2
    }
    gt <- gbi_grad_tau(mats$K, mats$H, mats$b, lambda, tau, eps)
    g <- tau*gt; if(!is.finite(g)) g <- 0; step <- step_tau
    for (ls in 1:20){
      tau_try <- exp(lntau + step*g)
      tau_try <- min(max(tau_try, tau_bounds[1]), tau_bounds[2])
      Ltry <- GBI_elbo(mats$K, mats$H, mats$b, lambda, tau_try, eps)
      if (is.finite(Ltry) && Ltry >= Lcur - 1e-12){ tau<-tau_try; lntau<-log(tau); Lcur<-Ltry; improved<-TRUE; break } else step <- step/2
    }
    ders <- build_sigma_derivs(X, sigma, K=mats$K)
    gs <- gbi_grad_sigma(mats$K, mats$H, mats$b, lambda, tau, eps, ders$dK, ders$dH, ders$db)
    g <- sigma*gs; if(!is.finite(g)) g <- 0; step <- step_sigma
    for (ls in 1:20){
      sigma_try <- exp(lnsigma + step*g)
      sigma_try <- min(max(sigma_try, smin), smax)
      mats_try <- build_mats(X, sigma_try, score_p0)
      Ltry <- GBI_elbo(mats_try$K, mats_try$H, mats_try$b, lambda, tau, eps)
      if (is.finite(Ltry) && Ltry >= Lcur - 1e-12){ sigma<-sigma_try; lnsigma<-log(sigma); mats<-mats_try; Lcur<-Ltry; improved<-TRUE; break } else step <- step/2
    }
    if (!improved || step_sigma*abs(g) < tol) break
  }
  post <- solve_post_gbi(mats$H, mats$K, mats$b, lambda, tau, eps, Tn)
  list(X=X, sigma=sigma, lambda=lambda, tau=tau, eps=eps, elbo=Lcur, m=post$m,
       H=mats$H, K=mats$K, b=mats$b, x_center=x_center, x_scale=x_scale, 
       standardize=standardize, score_p0=score_p0)
}

# predict (GBI)
predict_f_gbi <- function(fit, Xnew){
  Xnew <- as.matrix(Xnew)
  log_p0_val <- 0
  if (isTRUE(fit$standardize)){
    Xnew_std <- sweep(Xnew, 2, fit$x_center, "-")
    Xnew_std <- sweep(Xnew_std, 2, fit$x_scale,  "/")
  } else {
    Xnew_std <- Xnew
  }
  if (!is.null(fit$score_p0)) {
      # Assuming p0 is N(0,I), log p0(x) = -0.5 * sum(x^2) + C
      log_p0_val <- -0.5 * rowSums(Xnew_std^2)
  }
  Tn <- nrow(fit$X); out <- matrix(0, nrow(Xnew_std), Tn)
  for (i in 1:nrow(Xnew_std)){
    diff <- sweep(fit$X, 2, Xnew_std[i,], FUN="-"); r2 <- rowSums(diff^2)
    out[i,] <- exp(- r2 / (2 * fit$sigma^2))
  }
  as.numeric(out %*% fit$m) + log_p0_val
}
predict_den_gbi <- function(fit, Xnew) exp(predict_f_gbi(fit, Xnew))
```

# 1D 데이터 (2개) — EB vs GBI

## 1D Bimodal Mixture

```{r}
set.seed(101)
X1_mix <- matrix(c(rnorm(150, -1, 0.7), rnorm(200, 2, 0.7)), ncol = 1)

# EB with p0
fit_eb <- ebf_fit(X1_mix, eps=1e-6, score_p0 = score_p0_gaussian)
xs <- seq(min(X1_mix)-2, max(X1_mix)+2, length.out=400)
d_eb <- dens1d_eb(fit_eb, xs)

# GBI with p0
fit_gb <- fit_gbi(X1_mix, eps=1e-6, score_p0 = score_p0_gaussian)
d_gb <- dens1d_gbi(fit_gb, xs)

# True density
d_true <- 0.5 * dnorm(xs, -2, 0.7) + 0.5 * dnorm(xs, 2, 0.7)

par(mfrow=c(1,2))
hist(X1_mix, breaks=30, freq=FALSE, main="EB with p0=N(0,1)", xlab="x", col="grey90", border="white", ylim=range(0, d_eb, d_gb, d_true))
lines(xs, d_eb, lwd=2, col="blue")
lines(xs, d_true, lwd=2, lty=2, col="gray40")
legend("topright", legend=c("Estimate", "True"), col=c("blue", "gray40"), lty=c(1,2), lwd=2, bty="n")

hist(X1_mix, breaks=30, freq=FALSE, main="GBI with p0=N(0,1)", xlab="x", col="grey90", border="white", ylim=range(0, d_eb, d_gb, d_true))
lines(xs, d_gb, lwd=2, col="red")
lines(xs, d_true, lwd=2, lty=2, col="gray40")
legend("topright", legend=c("Estimate", "True"), col=c("red", "gray40"), lty=c(1,2), lwd=2, bty="n")

par(mfrow=c(1,1))
```

## 1D Gamma (Asymmetric)

```{r}
set.seed(102)
X1_gamma <- matrix(rgamma(300, shape = 2, rate = 1.5), ncol = 1)

# EB with p0
fit_eb <- ebf_fit(X1_gamma, eps=1e-6, score_p0 = score_p0_gaussian)
xs <- seq(0, max(X1_gamma)+2, length.out=400)
d_eb <- dens1d_eb(fit_eb, xs)

# GBI with p0
fit_gb <- fit_gbi(X1_gamma, eps=1e-6, score_p0 = score_p0_gaussian)
d_gb <- dens1d_gbi(fit_gb, xs)

# True density
d_true <- dgamma(xs, shape = 2, rate = 1.5)

par(mfrow=c(1,2))
hist(X1_gamma, breaks=30, freq=FALSE, main="EB with p0=N(0,1)", xlab="x", col="grey90", border="white", ylim=range(0, d_eb, d_gb, d_true))
lines(xs, d_eb, lwd=2, col="blue")
lines(xs, d_true, lwd=2, lty=2, col="gray40")
legend("topright", legend=c("Estimate", "True"), col=c("blue", "gray40"), lty=c(1,2), lwd=2, bty="n")

hist(X1_gamma, breaks=30, freq=FALSE, main="GBI with p0=N(0,1)", xlab="x", col="grey90", border="white", ylim=range(0, d_eb, d_gb, d_true))
lines(xs, d_gb, lwd=2, col="red")
lines(xs, d_true, lwd=2, lty=2, col="gray40")
legend("topright", legend=c("Estimate", "True"), col=c("red", "gray40"), lty=c(1,2), lwd=2, bty="n")

par(mfrow=c(1,1))
```


# 2D 데이터 (2개) — EB vs GBI

```{r 2d plotting util}

plot_density_2d <- function(X, fit, pred_fun, main_title, grid_n=120){
  # fit 객체에 저장된 x_center와 x_scale을 사용해 원본 데이터 스케일로 복원
  X_orig <- if (isTRUE(fit$standardize)) {
    sweep(sweep(fit$X, 2, fit$x_scale, "*"), 2, fit$x_center, "+")
  } else {
    fit$X
  }
  
  rng <- apply(X_orig, 2, range)
  pad_x <- (rng[2,1] - rng[1,1]) * 0.1
  pad_y <- (rng[2,2] - rng[1,2]) * 0.1
  
  gx <- seq(rng[1,1] - pad_x, rng[2,1] + pad_x, length.out=grid_n)
  gy <- seq(rng[1,2] - pad_y, rng[2,2] + pad_y, length.out=grid_n)
  G <- expand.grid(gx, gy)
  
  # pred_fun은 내부적으로 표준화를 처리하므로 원본 스케일 그리드를 전달
  den_vals <- pred_fun(fit, as.matrix(G))
  
  # 밀도 값이 음수이거나 비정상적으로 큰 경우를 대비
  den_vals[den_vals < 0] <- 0
  den <- matrix(den_vals, grid_n, grid_n)
  
  image(gx, gy, den, main=main_title, xlab="x1", ylab="x2", col = viridisLite::viridis(256))
  points(X_orig, pch=19, cex=0.3, col=rgb(1,1,1,0.5)) # 반투명 흰색 점
  contour(gx, gy, den, add=TRUE, drawlabels=FALSE, col="white", nlevels=7)
}
```

## 2D Ring Shape

```{r}
set.seed(202)
n_ring <- 300
radius <- rnorm(n_ring, mean = 3, sd = 0.3)
angle <- runif(n_ring, 0, 2*pi)
x_r <- radius * cos(angle)
y_r <- radius * sin(angle)
X2_ring <- cbind(x_r, y_r)

# EB with p0
fit_eb <- ebf_fit(X2_ring, eps=1e-6, score_p0 = score_p0_gaussian)
# GBI with p0
fit_gb <- fit_gbi(X2_ring, eps=1e-6, score_p0 = score_p0_gaussian)

par(mfrow=c(1,2))
plot_density_2d(X2_ring, fit_eb, predict_den_eb, "EB with p0=N(0,I)")
plot_density_2d(X2_ring, fit_gb, predict_den_gbi, "GBI with p0=N(0,I)")
par(mfrow=c(1,1))
```

## 2D Three Clusters

```{r}
if (!requireNamespace("MASS", quietly = TRUE)) stop("Package 'MASS' required for mvrnorm.")
set.seed(203)
X2_cluster <- rbind(
  MASS::mvrnorm(100, mu = c(-1.5, 1.5), Sigma = diag(2) * 0.4),
  MASS::mvrnorm(100, mu = c(1.5, 1.5),  Sigma = diag(2) * 0.4),
  MASS::mvrnorm(180, mu = c(0, -1.5),  Sigma = diag(2) * 0.4)
)

# EB with p0
fit_eb <- ebf_fit(X2_cluster, eps=1e-6, score_p0 = score_p0_gaussian)
# GBI with p0
fit_gb <- fit_gbi(X2_cluster, eps=1e-6, score_p0 = score_p0_gaussian)

par(mfrow=c(1,2))
plot_density_2d(X2_cluster, fit_eb, predict_den_eb, "EB with p0=N(0,I)")
plot_density_2d(X2_cluster, fit_gb, predict_den_gbi, "GBI with p0=N(0,I)")
par(mfrow=c(1,1))
```
